#!/usr/bin/env python# -*- encoding: utf-8 -*-"""@File    :   svm_model_predict.py    @Modify Time      @Author    @Version    @Description------------      -------    --------    -----------2022/9/16 17:16   SeafyLiang   1.0       基于SVM模型的eol预测"""import numpy as npimport pandas as pdimport matplotlib.pyplot as pltimport seaborn as snsfrom sklearn.model_selection import train_test_splitfrom sklearn.preprocessing import MinMaxScalerfrom sklearn.svm import SVRfrom dataset_util import *# 加载数据B0005 = loadMat('B0005.mat')B0006 = loadMat('B0006.mat')B0007 = loadMat('B0007.mat')B0018 = loadMat('B0018.mat')# 解析数据成df表格# {'cycle', 'capacity', 'max_discharge_temp', 'max_charge_temp'}dfB0005 = getDataframe(B0005)# 绘制线性回归的残差。# 此函数将对x进行y回归（可能作为稳健或多项式回归），然后绘制残差的散点图。# 您可以选择将最低平滑度拟合到残差图，这可以帮助确定残差是否存在结构。# 理想情况下，如果假设满足，残差将随机分散在为零的中心线上，没有明显的模式。看起来像一个以0为中心的非结构化的点云。# 然而，我们的剩余图不是一个非结构化的点云。尽管响应变量和预测变量之间似乎存在线性关系，但残差图看起来更像一个漏斗。# 残差图显示，随着GrLivArea值的增加，方差也随之增加，这就是所谓的异方差特征。sns.residplot(dfB0005['cycle'], dfB0005['capacity'])plt.title('B0005-cyc-capc')plt.show()dfB0006 = getDataframe(B0006)dfB0007 = getDataframe(B0007)dfB0018 = getDataframe(B0018)# 绘制循环次数-容量图X = dfB0007['cycle']Y = dfB0007['capacity']fig, ax = plt.subplots(1, figsize=(12, 8))ax.scatter(X, Y, color='green', label='Battery')plt.title('B0007-cyc-capc')plt.show()# 切分训练、测试数据集X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.2, shuffle=False)# 滑动平均识别异常点 时序滑动窗口为10，平均值+1.5倍标准差lst_x, lst_y = rollingAverage(X_train, y_train)d = {'X_train': X_train.values, 'y_train': y_train.values}# 训练数据集清洗异常点d = pd.DataFrame(d)d = d[~d['X_train'].isin(lst_x)]X_train = d['X_train']y_train = d['y_train']# 训练数据清洗可视化fig, ax = plt.subplots(1, figsize=(12, 8))ax.scatter(X_train, y_train, color='green', label='Battery capacity data')ax.scatter(lst_x, lst_y, color='red', label='Outliers')ax.legend()plt.title('train_data_clear')plt.show()# 训练数据标准化X_train = X_train.values.reshape(-1, 1)y_train = y_train.values.reshape(-1, 1)# 定义SVR模型best_svr = SVR(C=20, epsilon=0.0001, gamma=0.00001, cache_size=200, kernel='rbf', max_iter=-1, shrinking=True,               tol=0.001, verbose=False)# 模型训练best_svr.fit(X_train, y_train)# 模型预测y_pred = best_svr.predict(X.values.reshape(-1, 1))# 模型训练结果可视化fig, ax = plt.subplots(1, figsize=(12, 8))ax.plot(X, Y, color='green', label='Battery capacity data')ax.plot(X, y_pred, color='red', label='Fitted model')ax.set(xlabel='Time in seconds', ylabel='capacity', title='Discharging performance at 43°C')ax.legend()plt.show()# B0005电池：不同数据占比训练并预测，结果可视化对比X = dfB0005['cycle']Y = dfB0005['capacity']ratios = [40, 30, 20, 10]for ratio in ratios:    X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=ratio, shuffle=False)    lst_x, lst_y = rollingAverage(X_train, y_train)    d = {'X_train': X_train.values, 'y_train': y_train.values}    d = pd.DataFrame(d)    d = d[~d['X_train'].isin(lst_x)]    X_train = d['X_train']    y_train = d['y_train']    X_train = X_train.values.reshape(-1, 1)    y_train = y_train.values.reshape(-1, 1)    best_svr = SVR(C=20, epsilon=0.0001, gamma=0.0001, cache_size=200,                   kernel='rbf', max_iter=-1, shrinking=True, tol=0.001, verbose=False)    best_svr.fit(X_train, y_train)    if ratio == 40:        y_pred_40 = best_svr.predict(X.values.reshape(-1, 1))    elif ratio == 30:        y_pred_30 = best_svr.predict(X.values.reshape(-1, 1))    elif ratio == 20:        y_pred_20 = best_svr.predict(X.values.reshape(-1, 1))    elif ratio == 10:        y_pred_10 = best_svr.predict(X.values.reshape(-1, 1))fig, ax = plt.subplots(1, figsize=(12, 8))ax.plot(X, Y, color='black', label='Battery Capacity')ax.plot(X, y_pred_40, color='red', label='Prediction with train size of 60%')ax.plot(X, y_pred_30, color='blue', label='Prediction with train size of 70%')ax.plot(X, y_pred_20, color='green', label='Prediction with train size of 80%')ax.plot(X, y_pred_10, color='yellow', label='Prediction with train size of 90%')ax.set(xlabel='Time in seconds', ylabel='capacity', title='Model performance for Battery 05')ax.legend()plt.show()# B0006电池：不同数据占比训练并预测，结果可视化对比X = dfB0006['cycle']Y = dfB0006['capacity']ratios = [40, 30, 20, 10]for ratio in ratios:    X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=ratio, shuffle=False)    lst_x, lst_y = rollingAverage(X_train, y_train)    d = {'X_train': X_train.values, 'y_train': y_train.values}    d = pd.DataFrame(d)    d = d[~d['X_train'].isin(lst_x)]    X_train = d['X_train']    y_train = d['y_train']    X_train = X_train.values.reshape(-1, 1)    y_train = y_train.values.reshape(-1, 1)    best_svr = SVR(C=10, epsilon=0.0001, gamma=0.0001, cache_size=200,                   kernel='rbf', max_iter=-1, shrinking=True, tol=0.001, verbose=False)    best_svr.fit(X_train, y_train)    if ratio == 40:        y_pred_40 = best_svr.predict(X.values.reshape(-1, 1))    elif ratio == 30:        y_pred_30 = best_svr.predict(X.values.reshape(-1, 1))    elif ratio == 20:        y_pred_20 = best_svr.predict(X.values.reshape(-1, 1))    elif ratio == 10:        y_pred_10 = best_svr.predict(X.values.reshape(-1, 1))fig, ax = plt.subplots(1, figsize=(12, 8))ax.plot(X, Y, color='black', label='Battery Capacity')ax.plot(X, y_pred_40, color='red', label='Prediction with train size of 60%')ax.plot(X, y_pred_30, color='blue', label='Prediction with train size of 70%')ax.plot(X, y_pred_20, color='green', label='Prediction with train size of 80%')ax.plot(X, y_pred_10, color='yellow', label='Prediction with train size of 90%')ax.set(xlabel='Time in seconds', ylabel='capacity', title='Model performance for Battery 06')ax.legend()plt.show()# B0007电池：不同数据占比训练并预测，结果可视化对比X = dfB0007['cycle']Y = dfB0007['capacity']ratios = [40, 30, 20, 10]for ratio in ratios:    X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=ratio, shuffle=False)    lst_x, lst_y = rollingAverage(X_train, y_train)    d = {'X_train': X_train.values, 'y_train': y_train.values}    d = pd.DataFrame(d)    d = d[~d['X_train'].isin(lst_x)]    X_train = d['X_train']    y_train = d['y_train']    X_train = X_train.values.reshape(-1, 1)    y_train = y_train.values.reshape(-1, 1)    best_svr = SVR(C=10, epsilon=0.0001, gamma=0.0001, cache_size=200,                   kernel='rbf', max_iter=-1, shrinking=True, tol=0.001, verbose=False)    best_svr.fit(X_train, y_train)    if ratio == 40:        y_pred_40 = best_svr.predict(X.values.reshape(-1, 1))    elif ratio == 30:        y_pred_30 = best_svr.predict(X.values.reshape(-1, 1))    elif ratio == 20:        y_pred_20 = best_svr.predict(X.values.reshape(-1, 1))    elif ratio == 10:        y_pred_10 = best_svr.predict(X.values.reshape(-1, 1))fig, ax = plt.subplots(1, figsize=(12, 8))ax.plot(X, Y, color='black', label='Battery Capacity')ax.plot(X, y_pred_40, color='red', label='Prediction with train size of 60%')ax.plot(X, y_pred_30, color='blue', label='Prediction with train size of 70%')ax.plot(X, y_pred_20, color='green', label='Prediction with train size of 80%')ax.plot(X, y_pred_10, color='yellow', label='Prediction with train size of 90%')ax.set(xlabel='Time in seconds', ylabel='capacity', title='Model performance for Battery 07')ax.legend()plt.show()# B0018电池：不同数据占比训练并预测，结果可视化对比X = dfB0018['cycle']Y = dfB0018['capacity']ratios = [40, 30, 20, 10]for ratio in ratios:    X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=ratio, shuffle=False)    lst_x, lst_y = rollingAverage(X_train, y_train)    d = {'X_train': X_train.values, 'y_train': y_train.values}    d = pd.DataFrame(d)    d = d[~d['X_train'].isin(lst_x)]    X_train = d['X_train']    y_train = d['y_train']    X_train = X_train.values.reshape(-1, 1)    y_train = y_train.values.reshape(-1, 1)    best_svr = SVR(C=20, epsilon=0.0001, gamma=0.00001, cache_size=200,                   kernel='rbf', max_iter=-1, shrinking=True, tol=0.001, verbose=False)    best_svr.fit(X_train, y_train)    if ratio == 40:        y_pred_40 = best_svr.predict(X.values.reshape(-1, 1))    elif ratio == 30:        y_pred_30 = best_svr.predict(X.values.reshape(-1, 1))    elif ratio == 20:        y_pred_20 = best_svr.predict(X.values.reshape(-1, 1))    elif ratio == 10:        y_pred_10 = best_svr.predict(X.values.reshape(-1, 1))fig, ax = plt.subplots(1, figsize=(12, 8))ax.plot(X, Y, color='black', label='Battery Capacity')ax.plot(X, y_pred_40, color='red', label='Prediction with train size of 60%')ax.plot(X, y_pred_30, color='blue', label='Prediction with train size of 70%')ax.plot(X, y_pred_20, color='green', label='Prediction with train size of 80%')ax.plot(X, y_pred_10, color='yellow', label='Prediction with train size of 90%')ax.set(xlabel='Time in seconds', ylabel='capacity', title='Model performance for Battery 18')ax.legend()plt.show()